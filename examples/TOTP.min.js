(function(u,a){typeof exports=="object"&&typeof module<"u"?a(exports):typeof define=="function"&&define.amd?define(["exports"],a):(u=typeof globalThis<"u"?globalThis:u||self,a(u.OTP={}))})(this,function(u){"use strict";var W=Object.defineProperty;var v=(u,a,y)=>a in u?W(u,a,{enumerable:!0,configurable:!0,writable:!0,value:y}):u[a]=y;var g=(u,a,y)=>v(u,typeof a!="symbol"?a+"":a,y);function a(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function y(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function L(e,...t){if(!y(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function T(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");a(e.outputLen),a(e.blockLen)}function m(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function S(e,t){L(e);const s=t.outputLen;if(e.length<s)throw new Error("digestInto() expects output buffer of length at least "+s)}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const A=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),l=(e,t)=>e<<32-t|e>>>t;function _(e){if(typeof e!="string")throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array(new TextEncoder().encode(e))}function U(e){return typeof e=="string"&&(e=_(e)),L(e),e}class I{clone(){return this._cloneInto()}}function C(e){const t=i=>e().update(U(i)).digest(),s=e();return t.outputLen=s.outputLen,t.blockLen=s.blockLen,t.create=()=>e(),t}class D extends I{constructor(t,s){super(),this.finished=!1,this.destroyed=!1,T(t);const i=U(s);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,r=new Uint8Array(n);r.set(i.length>n?t.create().update(i).digest():i);for(let o=0;o<r.length;o++)r[o]^=54;this.iHash.update(r),this.oHash=t.create();for(let o=0;o<r.length;o++)r[o]^=106;this.oHash.update(r),r.fill(0)}update(t){return m(this),this.iHash.update(t),this}digestInto(t){m(this),L(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:s,iHash:i,finished:n,destroyed:r,blockLen:o,outputLen:c}=this;return t=t,t.finished=n,t.destroyed=r,t.blockLen=o,t.outputLen=c,t.oHash=s._cloneInto(t.oHash),t.iHash=i._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const k=(e,t,s)=>new D(e,t).update(s).digest();k.create=(e,t)=>new D(e,t);function O(e,t,s,i){if(typeof e.setBigUint64=="function")return e.setBigUint64(t,s,i);const n=BigInt(32),r=BigInt(4294967295),o=Number(s>>n&r),c=Number(s&r),f=i?4:0,d=i?0:4;e.setUint32(t+f,o,i),e.setUint32(t+d,c,i)}const j=(e,t,s)=>e&t^~e&s,M=(e,t,s)=>e&t^e&s^t&s;class P extends I{constructor(t,s,i,n){super(),this.blockLen=t,this.outputLen=s,this.padOffset=i,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=A(this.buffer)}update(t){m(this);const{view:s,buffer:i,blockLen:n}=this;t=U(t);const r=t.length;for(let o=0;o<r;){const c=Math.min(n-this.pos,r-o);if(c===n){const f=A(t);for(;n<=r-o;o+=n)this.process(f,o);continue}i.set(t.subarray(o,o+c),this.pos),this.pos+=c,o+=c,this.pos===n&&(this.process(s,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){m(this),S(t,this),this.finished=!0;const{buffer:s,view:i,blockLen:n,isLE:r}=this;let{pos:o}=this;s[o++]=128,this.buffer.subarray(o).fill(0),this.padOffset>n-o&&(this.process(i,0),o=0);for(let h=o;h<n;h++)s[h]=0;O(i,n-8,BigInt(this.length*8),r),this.process(i,0);const c=A(t),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const d=f/4,b=this.get();if(d>b.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<d;h++)c.setUint32(4*h,b[h],r)}digest(){const{buffer:t,outputLen:s}=this;this.digestInto(t);const i=t.slice(0,s);return this.destroy(),i}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:s,buffer:i,length:n,finished:r,destroyed:o,pos:c}=this;return t.length=n,t.pos=c,t.finished=r,t.destroyed=o,n%s&&t.buffer.set(i),t}}const $=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),p=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),x=new Uint32Array(64);class F extends P{constructor(){super(64,32,8,!1),this.A=p[0]|0,this.B=p[1]|0,this.C=p[2]|0,this.D=p[3]|0,this.E=p[4]|0,this.F=p[5]|0,this.G=p[6]|0,this.H=p[7]|0}get(){const{A:t,B:s,C:i,D:n,E:r,F:o,G:c,H:f}=this;return[t,s,i,n,r,o,c,f]}set(t,s,i,n,r,o,c,f){this.A=t|0,this.B=s|0,this.C=i|0,this.D=n|0,this.E=r|0,this.F=o|0,this.G=c|0,this.H=f|0}process(t,s){for(let h=0;h<16;h++,s+=4)x[h]=t.getUint32(s,!1);for(let h=16;h<64;h++){const H=x[h-15],w=x[h-2],E=l(H,7)^l(H,18)^H>>>3,B=l(w,17)^l(w,19)^w>>>10;x[h]=B+x[h-7]+E+x[h-16]|0}let{A:i,B:n,C:r,D:o,E:c,F:f,G:d,H:b}=this;for(let h=0;h<64;h++){const H=l(c,6)^l(c,11)^l(c,25),w=b+H+j(c,f,d)+$[h]+x[h]|0,B=(l(i,2)^l(i,13)^l(i,22))+M(i,n,r)|0;b=d,d=f,f=c,c=o+w|0,o=r,r=n,n=i,i=w+B|0}i=i+this.A|0,n=n+this.B|0,r=r+this.C|0,o=o+this.D|0,c=c+this.E|0,f=f+this.F|0,d=d+this.G|0,b=b+this.H|0,this.set(i,n,r,o,c,f,d,b)}roundClean(){x.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const G=C(()=>new F),V=e=>{const t=new ArrayBuffer(8),s=new Uint8Array(t);let i=e;for(let n=7;n>=0&&i!==0;n--)s[n]=i&255,i-=s[n],i/=256;return s};class N{constructor({secret:t,algorithm:s="SHA256",digits:i=6,period:n=30,position:r=[],label:o="OTPAuth",issuer:c="hikvision"}){g(this,"secret");g(this,"algorithm");g(this,"digits");g(this,"period");g(this,"issuer");g(this,"label");g(this,"position");this.secret=t,this.algorithm=s,this.digits=i,this.period=n,this.position=r,this.label=o,this.issuer=c}generate(t=Date.now()){const s=this.toHmacDigest(t),i=s[s.byteLength-1]&15;return(((s[i]&127)<<24|(s[i+1]&255)<<16|(s[i+2]&255)<<8|s[i+3]&255)%Math.pow(10,this.digits)).toString().padStart(this.digits,"0")}generateByPosition(t=Date.now(),s=[0,7,14,19,23,31]){const i=this.toHmacDigest(t);let n=[];for(let r=0;r<i.length;r++)if(s.includes(r)){const f=(i[r]&255)%10;n.push(f)}return n.join("")}toHmacDigest(t=Date.now()){const s=Math.floor(t/1e3/this.period);return k(G,this.secret,V(s))}toHmacHex(t=Date.now()){const s=this.toHmacDigest(t);return Array.from(s).map(i=>i.toString(16).padStart(2,"0")).join("")}toString(){const t=encodeURIComponent;return`otpauth://totp/${t(this.issuer)}:${t(this.label)}?issuer=${t(this.issuer)}&secret=${t(this.secret)}&algorithm=${t(this.algorithm)}&digits=${t(this.digits)}&period=${t(this.period)}`}}u.TOTP=N,Object.defineProperty(u,Symbol.toStringTag,{value:"Module"})});
