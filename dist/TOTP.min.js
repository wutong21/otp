(function(u,f){typeof exports=="object"&&typeof module<"u"?f(exports):typeof define=="function"&&define.amd?define(["exports"],f):(u=typeof globalThis<"u"?globalThis:u||self,f(u.OTP={}))})(this,function(u){"use strict";var W=Object.defineProperty;var R=(u,f,y)=>f in u?W(u,f,{enumerable:!0,configurable:!0,writable:!0,value:y}):u[f]=y;var b=(u,f,y)=>R(u,typeof f!="symbol"?f+"":f,y);function f(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function y(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function m(e,...t){if(!y(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error("Uint8Array expected of length "+t+", got length="+e.length)}function T(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");f(e.outputLen),f(e.blockLen)}function L(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function _(e,t){m(e);const s=t.outputLen;if(e.length<s)throw new Error("digestInto() expects output buffer of length at least "+s)}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const A=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),l=(e,t)=>e<<32-t|e>>>t;function S(e){if(typeof e!="string")throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array(new TextEncoder().encode(e))}function I(e){return typeof e=="string"&&(e=S(e)),m(e),e}class B{clone(){return this._cloneInto()}}function C(e){const t=i=>e().update(I(i)).digest(),s=e();return t.outputLen=s.outputLen,t.blockLen=s.blockLen,t.create=()=>e(),t}class D extends B{constructor(t,s){super(),this.finished=!1,this.destroyed=!1,T(t);const i=I(s);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,r=new Uint8Array(n);r.set(i.length>n?t.create().update(i).digest():i);for(let o=0;o<r.length;o++)r[o]^=54;this.iHash.update(r),this.oHash=t.create();for(let o=0;o<r.length;o++)r[o]^=106;this.oHash.update(r),r.fill(0)}update(t){return L(this),this.iHash.update(t),this}digestInto(t){L(this),m(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:s,iHash:i,finished:n,destroyed:r,blockLen:o,outputLen:h}=this;return t=t,t.finished=n,t.destroyed=r,t.blockLen=o,t.outputLen=h,t.oHash=s._cloneInto(t.oHash),t.iHash=i._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const E=(e,t,s)=>new D(e,t).update(s).digest();E.create=(e,t)=>new D(e,t);function $(e,t,s,i){if(typeof e.setBigUint64=="function")return e.setBigUint64(t,s,i);const n=BigInt(32),r=BigInt(4294967295),o=Number(s>>n&r),h=Number(s&r),a=i?4:0,d=i?0:4;e.setUint32(t+a,o,i),e.setUint32(t+d,h,i)}const O=(e,t,s)=>e&t^~e&s,j=(e,t,s)=>e&t^e&s^t&s;class M extends B{constructor(t,s,i,n){super(),this.blockLen=t,this.outputLen=s,this.padOffset=i,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=A(this.buffer)}update(t){L(this);const{view:s,buffer:i,blockLen:n}=this;t=I(t);const r=t.length;for(let o=0;o<r;){const h=Math.min(n-this.pos,r-o);if(h===n){const a=A(t);for(;n<=r-o;o+=n)this.process(a,o);continue}i.set(t.subarray(o,o+h),this.pos),this.pos+=h,o+=h,this.pos===n&&(this.process(s,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){L(this),_(t,this),this.finished=!0;const{buffer:s,view:i,blockLen:n,isLE:r}=this;let{pos:o}=this;s[o++]=128,this.buffer.subarray(o).fill(0),this.padOffset>n-o&&(this.process(i,0),o=0);for(let c=o;c<n;c++)s[c]=0;$(i,n-8,BigInt(this.length*8),r),this.process(i,0);const h=A(t),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const d=a/4,g=this.get();if(d>g.length)throw new Error("_sha2: outputLen bigger than state");for(let c=0;c<d;c++)h.setUint32(4*c,g[c],r)}digest(){const{buffer:t,outputLen:s}=this;this.digestInto(t);const i=t.slice(0,s);return this.destroy(),i}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:s,buffer:i,length:n,finished:r,destroyed:o,pos:h}=this;return t.length=n,t.pos=h,t.finished=r,t.destroyed=o,n%s&&t.buffer.set(i),t}}const P=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),p=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),x=new Uint32Array(64);class F extends M{constructor(){super(64,32,8,!1),this.A=p[0]|0,this.B=p[1]|0,this.C=p[2]|0,this.D=p[3]|0,this.E=p[4]|0,this.F=p[5]|0,this.G=p[6]|0,this.H=p[7]|0}get(){const{A:t,B:s,C:i,D:n,E:r,F:o,G:h,H:a}=this;return[t,s,i,n,r,o,h,a]}set(t,s,i,n,r,o,h,a){this.A=t|0,this.B=s|0,this.C=i|0,this.D=n|0,this.E=r|0,this.F=o|0,this.G=h|0,this.H=a|0}process(t,s){for(let c=0;c<16;c++,s+=4)x[c]=t.getUint32(s,!1);for(let c=16;c<64;c++){const H=x[c-15],w=x[c-2],k=l(H,7)^l(H,18)^H>>>3,U=l(w,17)^l(w,19)^w>>>10;x[c]=U+x[c-7]+k+x[c-16]|0}let{A:i,B:n,C:r,D:o,E:h,F:a,G:d,H:g}=this;for(let c=0;c<64;c++){const H=l(h,6)^l(h,11)^l(h,25),w=g+H+O(h,a,d)+P[c]+x[c]|0,U=(l(i,2)^l(i,13)^l(i,22))+j(i,n,r)|0;g=d,d=a,a=h,h=o+w|0,o=r,r=n,n=i,i=w+U|0}i=i+this.A|0,n=n+this.B|0,r=r+this.C|0,o=o+this.D|0,h=h+this.E|0,a=a+this.F|0,d=d+this.G|0,g=g+this.H|0,this.set(i,n,r,o,h,a,d,g)}roundClean(){x.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const G=C(()=>new F),V=e=>{const t=new ArrayBuffer(8),s=new Uint8Array(t);let i=e;for(let n=7;n>=0&&i!==0;n--)s[n]=i&255,i-=s[n],i/=256;return s};class N{constructor({secret:t,algorithm:s="SHA256",digits:i=6,period:n=30,position:r=[],issuer:o="",issuerInLabel:h=!0,label:a="OTPAuth"}){b(this,"secret");b(this,"algorithm");b(this,"digits");b(this,"period");b(this,"issuer");b(this,"issuerInLabel");b(this,"label");b(this,"position");this.secret=t,this.algorithm=s,this.digits=i,this.period=n,this.position=r,this.issuer=o,this.issuerInLabel=h,this.label=a}generate(t=Date.now()){const s=this.toHmacDigest(t),i=s[s.byteLength-1]&15;return(((s[i]&127)<<24|(s[i+1]&255)<<16|(s[i+2]&255)<<8|s[i+3]&255)%Math.pow(10,this.digits)).toString().padStart(this.digits,"0")}generateByPosition(t=Date.now(),s=[0,7,14,19,23,31]){const i=this.toHmacDigest(t);let n=[];for(let r=0;r<i.length;r++)if(s.includes(r)){const a=(i[r]&255)%10;n.push(a)}return n.join("")}toHmacDigest(t=Date.now()){const s=Math.floor(t/1e3/this.period);return E(G,this.secret,V(s))}toHmacHex(t=Date.now()){const s=this.toHmacDigest(t);return Array.from(s).map(i=>i.toString(16).padStart(2,"0")).join("")}toURI(){const t=encodeURIComponent;return`otpauth://totp/${this.issuer.length>0?this.issuerInLabel?`${t(this.issuer)}:${t(this.label)}?issuer=${t(this.issuer)}&`:`${t(this.label)}?issuer=${t(this.issuer)}&`:`${t(this.label)}?`}secret=${t(this.secret)}&algorithm=${t(this.algorithm)}&digits=${t(this.digits)}&period=${t(this.period)}`}}u.TOTP=N,Object.defineProperty(u,Symbol.toStringTag,{value:"Module"})});
